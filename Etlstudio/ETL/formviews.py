from .forms import *
from django.shortcuts import render, redirect, HttpResponse, get_object_or_404
from django.contrib import messages
from .serializers import *
import psycopg2
from .generalFunctions import *
import schedule as schedule
from .threads import scheduler_thread


# connection CRUD
def create_connection(request):
    form = ConnectionForms()
    if request.method == 'POST':
        form = ConnectionForms(request.POST)
        if form.is_valid():
            form.save()
            return redirect('getall_connection')

    context = {'form': form, 'title': 'Add New'}
    return render(request, 'create_connection.html', context)


def getall_connection(request):
    queryset = connections.objects.all()
    obj = queryset.order_by('id')
    return render(request, 'getall_connection.html', {'queryset': obj})


def update_connection(request, id):
    obj = connections.objects.get(id=id)
    form = ConnectionForms(instance=obj)
    if request.method == 'POST':
        form = ConnectionForms(request.POST, instance=obj)
        if form.is_valid():
            form.save()
            return redirect('getall_connection')
    context = {'form': form, 'title': 'Update'}
    return render(request, 'create_connection.html', context)


def delete_connection(request, id):
    obj = get_object_or_404(connections, id=id)
    obj.delete()
    return redirect('getall_connection')



def test(request, id):
    connection = connections.objects.get(id=id)
    return render(request, 'test.html', {'obj': connection})


# one time use only
def create_transferlog(request, id):
    connection_obj = connections.objects.get(id=id)
    obj_dict = ConnectionsSerialzer(instance=connection_obj).data
    schema_name = obj_dict.get('schema', 'public')

    table_name = 'transferlog'
    db_params = obj_dict

    connection, cursor = createConnectionNCursor(db_params)

    # Check if the table exists
    table_exists_query = f"SELECT to_regclass('{schema_name}.{table_name}') IS NOT NULL;"
    cursor.execute(table_exists_query)
    table_exists = cursor.fetchone()[0]
    print(table_name)
    print(table_exists)

    if table_exists:
        return HttpResponse('Table already exist')
    else:
        create_table_query = '''
        CREATE TABLE <<table_name>> (
            uuid int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
            source_transid varchar(10) NULL,
            source_username varchar(30) NULL,
            source_createdon timestamptz NOT NULL,
            source_modifiedon timestamptz NOT NULL,
            core_api varchar(100) NULL,
            status varchar(2) NULL,
            source_tablename varchar(50) NULL,
            source_sql varchar(4000) NULL,
            record_id int8 NOT NULL,
            errorlog text NULL,
            CONSTRAINT transferlog_pkey PRIMARY KEY (uuid)
        );'''

        create_table_query = create_table_query.replace('<<table_name>>', table_name)
        cursor.execute(create_table_query)
        connection.commit()
        cursor.close()
        connection.close()
        return HttpResponse('Table created succesfully')



# ========================== CRUD SchedulesForms, Schedules ==========================
def create_job(request):
    form = SchedulesForms()
    if request.method == 'POST':
        form = SchedulesForms(request.POST)

        if form.is_valid():
            form.save()
            return redirect('getall_api')
        else:
            error_messages = '\n'.join([f'{field}: {", ".join(errors)}' for field, errors in form.errors.items()])
            return HttpResponse(f'Form not valid. Errors:\n{error_messages}')
    else:
        context = {'form': form, 'title': 'Add New'}
        return render(request, 'create_job.html', context)


def getall_api(request):
    queryset = Jobs.objects.all().order_by('id')
    from .threads import scheduler_thread
    if scheduler_thread:
        animation = scheduler_thread.is_alive()
    else:
        animation = False
    print('animation', animation)

    context = {'queryset': queryset, 'animation': animation}
    # return render(request, 'getall_api.html', context)
    return render(request, 'list_services.html', context)


def update_api(request, id):
    obj = Jobs.objects.get(id=id)
    form = SchedulesForms(instance=obj)
    if request.method == 'POST':
        form = SchedulesForms(request.POST, instance=obj)
        if form.is_valid():
            form.save()
            return redirect('getall_api')
    context = {'form': form, 'title': 'Update'}
    return render(request, 'create_job.html', context)


# start_run_separate and stop_run_separate are moved to threads.py to handle the global thread
# If an api service is updated to run separately we have to stop_scheduler to avoid the thread conflicts.
# To clear the threads I have moved the start_run_separate and stop_run_separate to threads.py
# To clear the threads I have moved the start_run_separate and stop_run_separate to threads.py


def delete_api(request, id):
    Jobs.objects.get(id=id).delete()
    return redirect('getall_api')


def activate_job(request, id):
    job = Jobs.objects.get(id=id)
    job.active = True
    job.save()
    return redirect('getall_api')


def deactivate_job(request, id):
    job = Jobs.objects.get(id=id)
    job.active = False
    job.save()
    return redirect('getall_api')


# ======================== CRUD operation for service_timer =============================
def createfirsttimer(request):
    form = service_timerForms()
    print(form)
    if request.method == 'POST':
        form = service_timerForms(request.POST)
        if form.is_valid():
            result = form.save()
            print(result.pk)
            if result.pk:
                return HttpResponse('Object Saved')
            else:
                return HttpResponse('Use update')
        else:
            messages.error(request, 'Form not valid')
            return HttpResponse('Error')

    else:
        context = {'form': form}
        return render(request, 'configurations.html', context)


def config_home(request):
    return render(request, 'configurations.html', {})


def selectconfig(request):
    print('selectconfig')
    return render(request, 'config02.html', {})


def config_byinterval(request):
    obj = service_timer.objects.first()
    form = service_timerbyinterval(instance=obj)
    if request.method == 'POST':
        form = service_timerbyinterval(request.POST, instance=obj)
        if form.is_valid():
            print(form)
            obj = form.save(commit=False)
            obj.time_period = 'byinterval'
            # obj.timeinterval = None
            # obj.time_period = None
            obj.minutes_for_hour = None
            obj.time_for_day = None
            obj.day_name_for_week = None
            obj.time_for_week = None
            obj.save()
            return redirect('config_home')
        else:
            return HttpResponse('Form invalid')
    else:
        context = {'form': form, 'title': 'Auto Run Interval'}
        return render(request, 'config03.html', context)


def config_hourly(request):
    obj = service_timer.objects.first()
    form = service_timerHourlyForms
    if request.method == 'POST':
        form = service_timerHourlyForms(request.POST, instance=obj)
        if form.is_valid():
            print(form)
            obj = form.save(commit=False)
            obj.time_period = 'hour'

            obj.timeinterval = None
            # obj.time_period = None
            # obj.minutes_for_hour = None
            obj.time_for_day = None
            obj.day_name_for_week = None
            obj.time_for_week = None
            obj.save()
            return redirect('config_home')
        else:
            return HttpResponse('Form invalid')
    else:
        context = {'form': form, 'title': 'Configure Hourly'}
        return render(request, 'config03.html', context)


def config_daily(request):
    obj = service_timer.objects.first()
    form = service_timerDailyForms
    if request.method == 'POST':
        form = service_timerDailyForms(request.POST, instance=obj)
        if form.is_valid():
            print(form)
            obj = form.save(commit=False)
            obj.time_period = 'day'

            obj.timeinterval = None
            obj.minutes_for_hour = None
            # obj.time_for_day = None
            obj.day_name_for_week = None
            obj.time_for_week = None
            obj.save()
            return redirect('config_home')
        else:
            return HttpResponse('Form invalid')
    else:
        context = {'form': form, 'title': 'Configure Daily'}
        return render(request, 'config03.html', context)


def config_weekly(request):
    obj = service_timer.objects.first()
    form = service_timerWeeklyForms
    if request.method == 'POST':
        form = service_timerWeeklyForms(request.POST, instance=obj)
        if form.is_valid():
            print(form)
            obj = form.save(commit=False)
            obj.time_period = 'week'
            obj.timeinterval = None
            obj.minutes_for_hour = None
            obj.time_for_day = None
            # obj.day_name_for_week = None
            # obj.time_for_week = None
            obj.save()
            return redirect('config_home')
        else:
            return HttpResponse('Form invalid')
    else:
        context = {'form': form, 'title': 'Configure Weekly'}
        return render(request, 'config03.html', context)


# ========================= Servive Operations ==========================
## this function updated in formviews_v2
# def testservice(request, id):
#     apiObject = get_object_or_404(Jobs, id=id)
#     connection = apiObject.connection_name
#     table = connection.schema + '.transferlog'
#     api = apiObject.source_api
#     url = apiObject.url
#     db_params = ConnectionsSerialzer(instance=connection).data
#     connection, cursor, list_of_api_rows = extract_listoftrans_rows(api, table, db_params)
#     dict_of_executed_rows = generate_sql_executed_rows(connection, cursor, list_of_api_rows, table)
#     schedule_object = Jobs.objects.get(url=url)
#     print(timezone.now())
#     schedule_object.last_executed = timezone.now()
#     schedule_object.save()
#     # print(url, table, api, dict_of_executed_rows)
#     return HttpResponse(dict_of_executed_rows.items())


# # this function updated in formviews_v2
# def runSingleService(request, id):
#     apiObject = get_object_or_404(Jobs, id=id)
#     connection = apiObject.connection_name
#     table = connection.schema + '.transferlog'
#     api = apiObject.source_api
#     url = apiObject.url
#     db_params = ConnectionsSerialzer(instance=connection).data
#
#     connection, cursor, list_of_api_rows = extract_listoftrans_rows(api, table, db_params)
#     dict_of_executed_rows = generate_sql_executed_rows(connection, cursor, list_of_api_rows, table)
#     # print(url, table, api, dict_of_executed_rows)
#     post_jsons(url, dict_of_executed_rows, table, db_params)
#     return HttpResponse(dict_of_executed_rows.items())

# ========================== Run Services Separately ===============================



